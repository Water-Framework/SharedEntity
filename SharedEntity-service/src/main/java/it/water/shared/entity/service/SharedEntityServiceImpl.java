package it.water.shared.entity.service;

import it.water.core.api.action.ActionsManager;
import it.water.core.api.bundle.Runtime;
import it.water.core.api.entity.owned.OwnedResource;
import it.water.core.api.entity.shared.SharedEntity;
import it.water.core.api.model.Resource;
import it.water.core.api.model.User;
import it.water.core.api.permission.PermissionManager;
import it.water.core.api.registry.ComponentRegistry;
import it.water.core.api.repository.query.Query;
import it.water.core.api.service.BaseEntitySystemApi;
import it.water.core.api.service.integration.UserIntegrationClient;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.interceptors.annotations.Inject;
import it.water.core.permission.action.CrudActions;
import it.water.core.permission.action.ShareAction;
import it.water.core.permission.annotations.AllowGenericPermissions;
import it.water.core.permission.annotations.AllowPermissionsOnReturn;
import it.water.core.permission.exceptions.UnauthorizedException;
import it.water.repository.entity.model.exceptions.EntityNotFound;
import it.water.repository.entity.model.exceptions.NoResultException;
import it.water.repository.service.BaseEntityServiceImpl;
import it.water.shared.entity.api.SharedEntityApi;
import it.water.shared.entity.api.SharedEntitySystemApi;
import it.water.shared.entity.model.WaterSharedEntity;
import lombok.Getter;
import lombok.Setter;

import java.util.List;


/**
 * @Generated by Water Generator
 * Service Api Class for SharedEntity entity.
 */
@FrameworkComponent
public class SharedEntityServiceImpl extends BaseEntityServiceImpl<WaterSharedEntity> implements SharedEntityApi {

    @Inject
    @Getter
    @Setter
    private SharedEntitySystemApi systemService;

    @Inject
    @Getter
    @Setter
    private ComponentRegistry componentRegistry;

    @Inject
    @Setter
    private ActionsManager actionsManager;

    @Inject
    @Setter
    private UserIntegrationClient userIntegrationClient;

    @Inject
    @Setter
    private Runtime runtime;

    @Inject
    @Setter
    private PermissionManager permissionManager;

    public SharedEntityServiceImpl() {
        super(WaterSharedEntity.class);
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity update(WaterSharedEntity entity) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public void remove(long id) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity find(long id) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity find(Query filter) {
        throw new UnsupportedOperationException();
    }

    @Override
    public WaterSharedEntity save(WaterSharedEntity entity) {
        Class<?> entityClass = (entity.getEntityResourceName() != null) ? getEntityClass(entity.getEntityResourceName()) : null;

        if (!OwnedResource.class.isAssignableFrom(entityClass)) {
            throw new UnauthorizedException("Entity is not a Shared Entity!");
        }

        User user;
        try {
            user = this.userIntegrationClient.fetchUserByUserId(runtime.getSecurityContext().getLoggedEntityId());
        } catch (NoResultException exception) {
            throw new UnauthorizedException();
        }
        //Custom check on permission system
        //check if the user has the share permission for the entity identified by entityResourceName
        if (entityClass == null || (!user.isAdmin() && (actionsManager.getActions().get(entityClass.getName()) == null || !permissionManager.checkPermission(runtime.getSecurityContext().getLoggedUsername(), entity.getEntityResourceName(), actionsManager.getActions().get(entityClass.getName()).getAction(ShareAction.SHARE))))) {
            throw new UnauthorizedException();
        }
        if (entityClass == null || !SharedEntity.class.isAssignableFrom(entityClass)) {
            throw new RuntimeException("Entity " + entity.getEntityResourceName() + " is not a SharedEntity");
        }
        BaseEntitySystemApi<? extends WaterSharedEntity> systemService = this.componentRegistry.findEntitySystemApi(entity.getEntityResourceName());
        Resource resource;
        try {
            resource = systemService.find(entity.getEntityId());
        } catch (NoResultException exception) {
            throw new EntityNotFound();
        }
        if (!permissionManager.checkUserOwnsResource(user, resource)) {
            throw new UnauthorizedException();
        }
        String entityClassName = entityClass.getName();
        return doSave(entityClassName, entity, systemService);
    }


    private WaterSharedEntity doSave(String entityClassName, WaterSharedEntity entity, BaseEntitySystemApi<? extends WaterSharedEntity> entitySystemService) {
        SharedEntity e;
        try {
            e = (SharedEntity) entitySystemService.find(entity.getEntityId());
        } catch (NoResultException ex) {
            throw new EntityNotFound();
        }

        //check if the user owner of the entity is the logged one
        User u = e.getUserOwner();
        if (u.getId() != runtime.getSecurityContext().getLoggedEntityId()) {
            throw new UnauthorizedException();
        }
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        setSharedEntityUserId(entity);
        //do not check save permission for SharedEntity entities because if the share permission for an HyperIoTSharedEntity
        //implicitly has the permission to save a SharedEntity
        return super.save(entity);
    }

    @AllowGenericPermissions(actions = CrudActions.FIND)
    @AllowPermissionsOnReturn(actions = CrudActions.FIND)
    @Override
    public WaterSharedEntity findByPK(String entityResourceName, long entityId, long userId) {
        return systemService.findByPK(entityResourceName, entityId, userId);
    }


    @Override
    @AllowGenericPermissions(actions = CrudActions.REMOVE)
    public void removeByPK(WaterSharedEntity entity) {
        this.getLog().debug("Service Remove entity {}", entity);

        Class<?> entityClass = getEntityClass(entity.getEntityResourceName());

        //check if the user has the share permission for the entity identified by entityResourceName
        if (!permissionManager.checkPermission(runtime.getSecurityContext().getLoggedUsername(), entity.getEntityResourceName(), actionsManager.getActions().get(entityClass.getName()).getAction(ShareAction.SHARE))) {
            throw new UnauthorizedException();
        } else {
            //get the system service of the entity identified by entityResourceName
            BaseEntitySystemApi<? extends SharedEntity> systemService = this.componentRegistry.findEntitySystemApi(entityClass.getName());

            //find the entity
            SharedEntity e;
            try {
                e = systemService.find(entity.getEntityId());
            } catch (NoResultException ex) {
                throw new EntityNotFound();
            }

            //check if the user owner of the entity is the logged one
            User u = e.getUserOwner();
            if (u.getId() != runtime.getSecurityContext().getLoggedEntityId()) {
                throw new UnauthorizedException();
            }
        }
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        setSharedEntityUserId(entity);
        //cheking shared entity exists
        try {
            entity = this.getSystemService().findByPK(entity.getEntityResourceName(), entity.getEntityId(), entity.getUserId());
        } catch (NoResultException var7) {
            throw new EntityNotFound();
        }

        if (entity != null) {
            getSystemService().removeByPK(entity.getEntityResourceName(), entity.getEntityId(), entity.getUserId());
        } else {
            throw new EntityNotFound();
        }
    }

    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<WaterSharedEntity> findByEntity(String entityResourceName, long entityId) {
        return
                systemService.findByEntity(entityResourceName, entityId);
    }

    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<WaterSharedEntity> findByUser(long userId) {
        return systemService.findByUser(userId);
    }

    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<Long> getSharingUsers(String entityResourceName, long entityId) {
        return systemService.getSharingUsers(entityResourceName, entityId);
    }

    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<Long> getEntityIdsSharedWithUser(String entityResourceName, long userId) {
        return systemService.getEntityIdsSharedWithUser(entityResourceName, userId);
    }

    private Class<?> getEntityClass(String resourceName) {
        try {
            return Class.forName(resourceName);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException("Class " + resourceName + " not found");
        }
    }

    private void setSharedEntityUserId(WaterSharedEntity entity) {
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        if (entity.getUserId() <= 0) {
            User foundUser = null;
            if (entity.getUserEmail() != null && !entity.getUserEmail().isBlank()) {
                foundUser = this.userIntegrationClient.fetchUserByEmailAddress(entity.getUserEmail());
            } else if (entity.getUsername() != null && !entity.getUsername().isBlank()) {
                foundUser = this.userIntegrationClient.fetchUserByUsername(entity.getUsername());
            }

            if (foundUser != null)
                entity.setUserId(foundUser.getId());
            else
                throw new EntityNotFound();
        } else {
            try {
                // find the user
                this.userIntegrationClient.fetchUserByUserId(entity.getUserId());
            } catch (NoResultException ex) {
                throw new RuntimeException("Impossible to share the specified resource");
            }
        }
    }
}
