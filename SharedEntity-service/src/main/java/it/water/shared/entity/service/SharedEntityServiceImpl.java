package it.water.shared.entity.service;

import java.util.List;

import it.water.core.api.action.ActionsManager;
import it.water.core.api.entity.shared.SharedEntity;
import it.water.core.api.model.Resource;
import it.water.core.api.model.User;
import it.water.core.api.permission.PermissionManager;
import it.water.core.api.registry.ComponentRegistry;
import it.water.core.api.repository.query.Query;
import it.water.core.api.service.BaseEntitySystemApi;
import it.water.core.api.service.integration.UserIntegrationClient;
import it.water.core.interceptors.annotations.FrameworkComponent;
import it.water.core.interceptors.annotations.Inject;
import it.water.core.model.exceptions.WaterRuntimeException;
import it.water.core.permission.action.CrudActions;
import it.water.core.permission.action.ShareAction;
import it.water.core.permission.annotations.AllowGenericPermissions;
import it.water.core.permission.annotations.AllowPermissionsOnReturn;
import it.water.core.permission.exceptions.UnauthorizedException;
import it.water.repository.entity.model.exceptions.EntityNotFound;
import it.water.repository.entity.model.exceptions.NoResultException;
import it.water.repository.service.BaseEntityServiceImpl;
import it.water.shared.entity.api.SharedEntityApi;
import it.water.shared.entity.api.SharedEntitySystemApi;
import it.water.shared.entity.model.WaterSharedEntity;
import lombok.Getter;
import lombok.Setter;


/**
 * @Generated by Water Generator
 * Service Api Class for SharedEntity entity.
 */
@FrameworkComponent
public class SharedEntityServiceImpl extends BaseEntityServiceImpl<WaterSharedEntity> implements SharedEntityApi {

    @Inject
    @Getter
    @Setter
    private SharedEntitySystemApi systemService;

    @Inject
    @Getter
    @Setter
    private ComponentRegistry componentRegistry;

    @Inject
    @Setter
    private ActionsManager actionsManager;

    @Inject
    @Setter
    private UserIntegrationClient userIntegrationClient;

    @Inject
    @Setter
    private PermissionManager permissionManager;

    public SharedEntityServiceImpl() {
        super(WaterSharedEntity.class);
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity update(WaterSharedEntity entity) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public void remove(long id) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity find(long id) {
        throw new UnsupportedOperationException();
    }

    //avoiding other interaction from outside
    @Override
    public WaterSharedEntity find(Query filter) {
        throw new UnsupportedOperationException();
    }

    /**
     * Saves a given WaterSharedEntity if the user has the necessary permissions and
     * the entity is a shared entity.
     *
     * @param entity The WaterSharedEntity to be saved, containing the necessary details
     *               like entity resource name, entity ID, and user ID.
     * @return The saved WaterSharedEntity.
     * @throws UnauthorizedException If the entity is not a shared entity, the user is
     *                               not authorized, or if the user does not have the
     *                               necessary permissions.
     * @throws EntityNotFound If the entity could not be found in the system.
     */
    @Override
    public WaterSharedEntity save(WaterSharedEntity entity) {
        Class<?> entityClass = getEntityClass(entity.getEntityResourceName());

        if (entityClass == null || !SharedEntity.class.isAssignableFrom(entityClass)) {
            throw new UnauthorizedException("Entity is not a Shared Entity or Shared Entity Class not found!");
        }

        User user = this.userIntegrationClient.fetchUserByUserId(this.getRuntime().getSecurityContext().getLoggedEntityId());

        //Custom check on permission system
        //check if the user has the share permission for the entity identified by entityResourceName
        if (user == null || (!user.isAdmin() && (actionsManager.getActions().get(entityClass.getName()) == null || !permissionManager.checkPermission(getRuntime().getSecurityContext().getLoggedUsername(), entity.getEntityResourceName(), actionsManager.getActions().get(entityClass.getName()).getAction(ShareAction.SHARE))))) {
            throw new UnauthorizedException();
        }
        //todo this logic implies that shared entity should stay in the same container
        //we have to move this logic to the permission system that should track wether an entity
        //is owned, shared and save this information inside the database
        BaseEntitySystemApi<? extends WaterSharedEntity> entitySystemService = this.componentRegistry.findEntitySystemApi(entity.getEntityResourceName());
        Resource resource;
        try {
            resource = entitySystemService.find(entity.getEntityId());
        } catch (NoResultException exception) {
            throw new EntityNotFound();
        }
        if (!permissionManager.checkUserOwnsResource(user, resource)) {
            throw new UnauthorizedException();
        }
        return doSave(entity);
    }


    private WaterSharedEntity doSave(WaterSharedEntity entity) {
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        setSharedEntityUserId(entity);
        //do not check save permission for SharedEntity entities because if the share permission for an HyperIoTSharedEntity
        //implicitly has the permission to save a SharedEntity
        return super.save(entity);
    }

    /**
     * Finds a WaterSharedEntity by its primary key, which includes the entity resource name, entity ID, and user ID.
     *
     * @param entityResourceName the name of the entity resource.
     * @param entityId the ID of the entity.
     * @param userId the ID of the user.
     * @return the WaterSharedEntity object that matches the given primary key or null if no such entity is found.
     */
    @AllowGenericPermissions(actions = CrudActions.FIND)
    @AllowPermissionsOnReturn(actions = CrudActions.FIND)
    @Override
    public WaterSharedEntity findByPK(String entityResourceName, long entityId, long userId) {
        return systemService.findByPK(entityResourceName, entityId, userId);
    }


    /**
     * Removes an entity identified by primary key and resource name if the user has the necessary permissions
     * and ownership.
     *
     * @param entity The shared entity to be removed, which includes the entity resource name,
     *               entity ID, and user ID.
     */
    @SuppressWarnings("unchecked")
    @Override
    @AllowGenericPermissions(actions = CrudActions.REMOVE)
    public void removeByPK(WaterSharedEntity entity) {
        this.getLog().debug("Service Remove entity {}", entity);

        Class<?> entityClass = getEntityClass(entity.getEntityResourceName());
        if(entityClass == null)
            throw new UnauthorizedException("Entity is not a Shared Entity or Shared Entity Class not found!");

        //check if the user has the share permission for the entity identified by entityResourceName
        if (!permissionManager.checkPermission(this.getRuntime().getSecurityContext().getLoggedUsername(), entity.getEntityResourceName(), actionsManager.getActions().get(entityClass.getName()).getAction(ShareAction.SHARE))) {
            throw new UnauthorizedException();
        } else {
            //get the system service of the entity identified by entityResourceName
            BaseEntitySystemApi<? extends SharedEntity> entitySystemService = this.componentRegistry.findEntitySystemApi(entityClass.getName());

            //find the entity
            SharedEntity e;
            try {
                e = entitySystemService.find(entity.getEntityId());
            } catch (NoResultException ex) {
                throw new EntityNotFound();
            }

            //check if the user owner of the entity is the logged one
            long userId = e.getOwnerUserId() != null ? e.getOwnerUserId(): 0L;
            if (userId != this.getRuntime().getSecurityContext().getLoggedEntityId()) {
                throw new UnauthorizedException();
            }
        }
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        setSharedEntityUserId(entity);
        //cheking shared entity exists
        try {
            entity = this.getSystemService().findByPK(entity.getEntityResourceName(), entity.getEntityId(), entity.getUserId());
        } catch (NoResultException var7) {
            throw new EntityNotFound();
        }

        if (entity != null) {
            getSystemService().removeByPK(entity.getEntityResourceName(), entity.getEntityId(), entity.getUserId());
        } else {
            throw new EntityNotFound();
        }
    }

    /**
     * Finds and returns a list of shared entities based on the given entity resource name and entity ID.
     *
     * @param entityResourceName the name of the entity resource to search for.
     * @param entityId the ID of the entity to search for.
     * @return a list of WaterSharedEntity objects that match the specified entity resource name and entity ID.
     */
    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<WaterSharedEntity> findByEntity(String entityResourceName, long entityId) {
        return
                systemService.findByEntity(entityResourceName, entityId);
    }

    /**
     * Finds and returns a list of shared entities associated with the specified user ID.
     *
     * @param userId the ID of the user whose shared entities should be retrieved.
     * @return a list of WaterSharedEntity objects that are associated with the specified user ID.
     */
    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<WaterSharedEntity> findByUser(long userId) {
        return systemService.findByUser(userId);
    }

    /**
     * Retrieves a list of IDs of users who have sharing permissions on the specified entity.
     *
     * @param entityResourceName the name of the entity resource to search for sharing users.
     * @param entityId the ID of the entity for which sharing users are to be retrieved.
     * @return a list of user IDs who have sharing permissions on the specified entity.
     */
    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<Long> getSharingUsers(String entityResourceName, long entityId) {
        return systemService.getSharingUsers(entityResourceName, entityId);
    }

    /**
     * Retrieves a list of entity IDs shared with a particular user.
     *
     * @param entityResourceName the name of the entity resource to search for shared entities.
     * @param userId the ID of the user with whom the entities are shared.
     * @return a list of entity IDs that are shared with the specified user.
     */
    @AllowGenericPermissions(actions = CrudActions.FIND)
    @Override
    public List<Long> getEntityIdsSharedWithUser(String entityResourceName, long userId) {
        return systemService.getEntityIdsSharedWithUser(entityResourceName, userId);
    }

    private Class<?> getEntityClass(String resourceName) {
        try {
            return Class.forName(resourceName);
        } catch (ClassNotFoundException e) {
            getLog().error(e.getMessage(),e);
        }
        return null;
    }

    private void setSharedEntityUserId(WaterSharedEntity entity) {
        //If user id is not specified we try to load user by email field or username.
        //if id nor  username nor  email are specified the service will raise an exception
        if (entity.getUserId() <= 0) {
            User foundUser = null;
            if (entity.getUserEmail() != null && !entity.getUserEmail().isBlank()) {
                foundUser = this.userIntegrationClient.fetchUserByEmailAddress(entity.getUserEmail());
            } else if (entity.getUsername() != null && !entity.getUsername().isBlank()) {
                foundUser = this.userIntegrationClient.fetchUserByUsername(entity.getUsername());
            }

            if (foundUser != null)
                entity.setUserId(foundUser.getId());
            else
                throw new EntityNotFound();
        } else {
            try {
                // find the user
                this.userIntegrationClient.fetchUserByUserId(entity.getUserId());
            } catch (NoResultException ex) {
                throw new WaterRuntimeException("Impossible to share the specified resource");
            }
        }
    }
}
